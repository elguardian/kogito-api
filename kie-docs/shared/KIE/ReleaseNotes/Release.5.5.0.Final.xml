<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="./../../" xml:id="s1" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>What is New and Noteworthy in Drools 5.5.0</title>

  <section xml:id="releaseNotes_5.5.0_Expert">
    <title>Drools Expert</title>

    <section>
      <title>Grouped accessors for nested objects</title>

      <para>We already allow nested accessors to be used as follows, where
      address is the nested object:</para>

      <programlisting>Person( name == "mark", address.city == "london", address.country == "uk" )</programlisting>

      <para>Now these accessors to nested objects can be grouped with a
      '.(...)' syntax providing more readable rules as it follows:</para>

      <programlisting>Person( name==  "mark", address.( city == "london", country ==  "uk") )</programlisting>

      <para>Note the '.' prefix, this is necessary to differentiate the nested
      object constraints from a method call.</para>
    </section>

    <section>
      <title>Inline casts and coercion</title>

      <para>When dealing with nested objects, we may need to cast to a
      subtype. Now it is possible to do that via the # symbol as in:</para>

      <programlisting>Person( name=="mark", address#LongAddress.country == "uk" )</programlisting>

      <para>This example casts Address to LongAddress, making its getters
      available. If the cast is not possible (instanceof returns false), the
      evaluation will be considered false. Also fully qualified names are
      supported:</para>

      <programlisting>Person( name=="mark", address#org.domain.LongAddress.country == "uk" )</programlisting>

      <para>It is possible to use multiple inline casts in the same
      expression:</para>

      <programlisting>Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</programlisting>

      <para>moreover, since we also support the instanceof operator, if that
      is used we will infer its results for further uses of that field, within
      that pattern:</para>

      <programlisting>Person(  name=="mark", address instanceof LongAddress, address.country == "uk" )</programlisting>
    </section>

    <section>
      <title>Conditional named consequences</title>

      <para>Sometimes the constraint of having one single consequence for each
      rule can be somewhat limiting and leads to verbose and difficult to be
      maintained repetitions like in the following example:</para>

      <programlisting>rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</programlisting>

      <para>It is already possible to partially overcome this problem by
      making the second rule extending the first one like in:</para>

      <programlisting>rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
    extends "Give 10% discount to customers older than 60"
when
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end</programlisting>

      <para>Anyway this feature makes it possible to define more labelled
      consequences other than the default one in a single rule, so, for
      example, the 2 former rules can be compacted in only one like it
      follows:</para>

      <programlisting>rule "Give 10% discount and free parking to customers older than 60"
when
    $customer : Customer( age &gt; 60 )
    do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</programlisting>

      <para>This last rule has 2 consequences, the usual default one, plus
      another one named "giveDiscount" that is activated, using the keyword
      do, as soon as a customer older than 60 is found in the knowledge base,
      regardless of the fact that he owns a car or not. The activation of a
      named consequence can be also guarded by an additional condition like in
      this further example:</para>

      <programlisting>rule "Give free parking to customers older than 60 and 10% discount to golden ones among them"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</programlisting>

      <para>The condition in the if statement is always evaluated on the
      pattern immediately preceding it. In the end this last, a bit more
      complicated, example shows how it is possible to switch over different
      conditions using a nested if/else statement:</para>

      <programlisting>rule "Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones"
when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount10]
    else if ( type == "Silver" ) break[giveDiscount5]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount10]
    modify($customer) { setDiscount( 0.1 ) };
then[giveDiscount5]
    modify($customer) { setDiscount( 0.05 ) };
end</programlisting>

      <para>Here the purpose is to give a 10% discount AND a free parking to
      Golden customers over 60, but only a 5% discount (without free parking)
      to the Silver ones. This result is achieved by activating the
      consequence named "giveDiscount5" using the keyword break instead of do.
      In fact do just schedules a consequence in the agenda, allowing the
      remaining part of the LHS to continue of being evaluated as per normal,
      while break also blocks any further pattern matching evaluation. Note,
      of course, that the activation of a named consequence not guarded by any
      condition with break doesn't make sense (and generates a compile time
      error) since otherwise the LHS part following it would be never
      reachable.</para>
    </section>

    <section>
      <title>Logging support</title>

      <para>Drools now has logging support. It can log to your favorite logger
      (such as logback, log4j, commons-logging, JDK logger, no logging, ...)
      through the SFL4J API.</para>
    </section>

    <section>
      <title>Null-safe dereferencing operator in Drools patterns</title>

      <para>The !. operator allows to derefencing in a null-safe way. More in
      details the matching algorithm requires the value to the left of the !.
      operator to be not null in order to give a positive result for pattern
      matching itself. In other words the pattern:</para>

      <programlisting>Person( $streetName : address!.street )</programlisting>

      <para>will be internally translated in:</para>

      <programlisting>Person( address != null, $streetName : address.street )</programlisting>

      <para>More information about the rationals that drove the decisions
      related to this implementation are available <link
      xlink:href="https://plus.google.com/u/0/b/101003552532172845268/101003552532172845268/posts/E5Q1geu8p6P">here</link>.</para>
    </section>
  </section>
</section>
